using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

namespace ProcessIsolation.Shared.Platform
{
    internal static class ProcessAffinity
    {
        public static string ToString(IntPtr affinity)
            => ToString(affinity, Environment.ProcessorCount);

        public static string ToString(IntPtr affinity, int maximumProcessorCount, bool shortenAll = true, bool concise = false)
        {
            if (maximumProcessorCount == -1)
            {
                maximumProcessorCount = Environment.ProcessorCount;
            }

            if (maximumProcessorCount < 1)
            {
                throw new ArgumentOutOfRangeException(nameof(maximumProcessorCount), maximumProcessorCount, "must provided at least one processor");
            }

            if ((long)maximumProcessorCount > int.MaxValue)
            {
                throw new ArgumentOutOfRangeException(nameof(maximumProcessorCount), maximumProcessorCount, "too many processors");
            }

            long affValue = affinity.ToInt64();
            int processorCount = maximumProcessorCount;

            long defValue = (long)Math.Pow(2, processorCount) - 1;
            if (affValue == defValue && shortenAll)
            {
                return $"(all {processorCount} cpus)";
            }

            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < IntPtr.Size * 8; i++)
            {
                long mask = (long)Math.Pow(2, i);
                if ((affValue & mask) == mask)
                {
                    if (!concise)
                    {
                        sb.Append("cpu");
                    }

                    sb.Append(i);
                    sb.Append(' ');
                }
            }
            return sb.ToString().Trim();
        }

        private static readonly char[] s_affinityDelimiters = { ' ', ',', ';', '|', ':' };

        /// <summary>
        /// Returns the possible delimiters that <see cref="Parse"/>
        /// understands.
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<char> GetAffinityDelimiters() => s_affinityDelimiters;

        /// <summary>
        /// Parse a processor affinity string representation into an affinity mask.
        /// </summary>
        /// <param name="str">A processor affinity string representation as generated by
        /// <see cref="ToString(IntPtr)"/></param>
        /// <returns>The <see cref="IntPtr"/>-value that represents the affinity mask.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="str"/> is <c>null</c></exception>
        /// <exception cref="FormatException"><paramref name="str"/> is not a valid string representation</exception>
        /// <seealso cref="ToString(IntPtr)"/>
        public static IntPtr Parse(string str)
        {
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }

            if (str.Length == 0)
            {
                throw new FormatException("Invalid empty processor affinity.");
            }

            long value = 0;

            foreach (string entry in str.Split(s_affinityDelimiters, StringSplitOptions.RemoveEmptyEntries))
            {
                string id = entry.Trim();
                if (id.StartsWith("cpu", StringComparison.OrdinalIgnoreCase))
                {
                    id = id.Substring("cpu".Length);
                }

                if (!int.TryParse(id, out int num) || num < 0 || (long)num >= int.MaxValue)
                {
                    throw new FormatException($"Invalid processor affinity '{str}', value '{entry}'.");
                }

                value |= (long)(1 << num);
            }

            return new IntPtr((int)value);
        }

        /// <summary>
        /// Attempt to parse a processor affinity string representation into an affinity mask.
        /// </summary>
        /// <param name="str">A processor affinity string representation as generated by
        /// <see cref="ToString(IntPtr)"/></param>
        /// <param name="affinity">The <see cref="IntPtr"/>-value that represents the affinity mask
        /// of the <paramref name="str"/> parameter, or <see cref="IntPtr.Zero"/> if the string
        /// representation is not valid.</param>
        /// <returns><c>true</c> when the string representation is valid, <c>false</c> otherwise.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="str"/> is <c>null</c></exception>
        /// <seealso cref="ToString(IntPtr)"/>
        public static bool TryParse(string str, out IntPtr affinity)
        {
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }

            affinity = IntPtr.Zero;

            if (str.Length == 0)
            {
                return false;
            }

            long value = 0;

            foreach (string entry in str.Split(s_affinityDelimiters, StringSplitOptions.RemoveEmptyEntries))
            {
                string id = entry.Trim();
                if (id.StartsWith("cpu", StringComparison.OrdinalIgnoreCase))
                {
                    id = id.Substring("cpu".Length);
                }

                if (!int.TryParse(id, out int num) || num < 0 || (long)num >= int.MaxValue)
                {
                    return false;
                }

                value |= (long)(1 << num);
            }

            affinity = new IntPtr((int)value);
            return true;
        }

        /// <summary>
        /// Count the number of processors that are set in an affinity mask.
        /// </summary>
        /// <param name="processAffinity"></param>
        /// <returns></returns>
        public static int CountActiveProcessors(IntPtr processAffinity)
            => CountActiveProcessors(processAffinity, Environment.ProcessorCount);

        /// <summary>
        /// Count the number of processors that are set in an affinity mask.
        /// </summary>
        /// <param name="processAffinity"></param>
        /// <param name="maximumProcessorCount"></param>
        /// <returns></returns>
        public static int CountActiveProcessors(IntPtr processAffinity, int maximumProcessorCount)
        {
            if (maximumProcessorCount == -1)
            {
                maximumProcessorCount = Environment.ProcessorCount;
            }

            if (maximumProcessorCount < 1)
            {
                throw new ArgumentOutOfRangeException(nameof(maximumProcessorCount), maximumProcessorCount, "must provided at least one processor");
            }

            if ((long)maximumProcessorCount > int.MaxValue)
            {
                throw new ArgumentOutOfRangeException(nameof(maximumProcessorCount), maximumProcessorCount, "too many processors");
            }

            int count = 0;
            long affValue = processAffinity.ToInt64();

            long defValue = (long)Math.Pow(2, maximumProcessorCount) - 1;
            if (affValue == defValue)
            {
                return maximumProcessorCount;
            }

            for (int i = 0; i < IntPtr.Size * 8; i++)
            {
                long mask = (long)Math.Pow(2, i);
                if ((affValue & mask) == mask)
                {
                    count++;
                }
            }

            return count;
        }

        /// <summary>
        /// Checks if a process is set inside an affinity mask.
        /// </summary>
        /// <param name="affinity"></param>
        /// <param name="processorIndex">The 0-based index of the processor</param>
        /// <returns></returns>
        public static bool IsProcessorActive(IntPtr affinity, int processorIndex)
        {
            if (processorIndex < 0 || processorIndex > 64)
            {
                throw new ArgumentOutOfRangeException(nameof(processorIndex), processorIndex, "Invalid processor index");
            }

            long mask = (long)Math.Pow(2, processorIndex);
            return (affinity.ToInt64() & mask) == mask;
        }

        /// <summary>
        /// Calculate an affinity mask for use with <see cref="Process.ProcessorAffinity"/> for the current system topology.
        /// </summary>
        /// <param name="processorCount">
        /// If the value is positive, the number of processors to use. <br/>
        /// If the value is negative, the number of processors to not use out of <see cref="Environment.ProcessorCount"/> available.
        /// Also see Remarks-Section.
        /// </param>
        /// <remarks>
        /// <p>If the he value of the <paramref name="processorCount"/> parameter would result in more processors to be
        /// included in the affinity mask, the result is an affinity mask that includes the maximum number of processors available.</p>
        /// <p>If the he value of the <paramref name="processorCount"/> parameter would result in zero processors to be
        /// included in the affinity mask, the result is an affinity mask that uses only one processor.</p>
        /// </remarks>
        /// <returns>
        /// A value that can be used with <see cref="Process.ProcessorAffinity"/> for the current system topology.
        /// </returns>
        public static IntPtr Calculate(int processorCount)
            => Calculate(processorCount, Environment.ProcessorCount);

        /// <summary>
        /// Calculate an affinity mask for use with <see cref="Process.ProcessorAffinity"/>.
        /// </summary>
        /// <param name="processorCount">
        /// If the value is positive, the number of processors to use. <br/>
        /// If the value is negative, the number of processors to not use out of <paramref name="maximumProcessorCount"/> available.
        /// Also see Remarks-Section.
        /// </param>
        /// <param name="maximumProcessorCount">
        /// The maximum number of processors available.
        /// </param>
        /// <remarks>
        /// <p>If the he value of the <paramref name="processorCount"/> parameter would result in more processors to be
        /// included in the affinity mask, the result is an affinity mask that includes the maximum number of processors available.</p>
        /// <p>If the he value of the <paramref name="processorCount"/> parameter would result in zero processors to be
        /// included in the affinity mask, the result is an affinity mask that uses only one processor.</p>
        /// </remarks>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="maximumProcessorCount"/> is less then 1 or larger than <see cref="Int32.MaxValue"/>
        /// </exception>
        /// <returns>
        /// A value that can be used with <see cref="Process.ProcessorAffinity"/> for the current system topology.
        /// </returns>
        public static IntPtr Calculate(int processorCount, int maximumProcessorCount)
        {
            if (maximumProcessorCount == -1)
            {
                maximumProcessorCount = Environment.ProcessorCount;
            }

            if (maximumProcessorCount < 1)
            {
                throw new ArgumentOutOfRangeException(nameof(maximumProcessorCount), maximumProcessorCount, "must provided at least one processor");
            }

            if ((long)maximumProcessorCount > int.MaxValue)
            {
                throw new ArgumentOutOfRangeException(nameof(maximumProcessorCount), maximumProcessorCount, "too many processors");
            }

            if (processorCount == int.MinValue || (processorCount < 0 && (maximumProcessorCount + processorCount) <= 0))
            {
                processorCount = 1;
            }

            if (processorCount < 0)
            {
                processorCount = maximumProcessorCount - -processorCount;
                return GetMask(processorCount, maximumProcessorCount);
            }

            return GetMask(processorCount, maximumProcessorCount);

            static IntPtr GetMask(int pc, int mp)
            {
                if (pc <= 0)
                {
                    pc = mp;
                }

                pc = Math.Min(pc, mp);

                if (IntPtr.Size == 8)
                {
                    return new IntPtr((long)Math.Pow(2, pc) - 1);
                }

                return new IntPtr((int)Math.Pow(2, pc) - 1);
            }
        }
    }
}
